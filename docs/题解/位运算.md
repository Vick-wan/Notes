# 位运算
## 异或
### [P3917 异或序列](https://www.luogu.com.cn/problem/P3917)
#### 题目描述
给出数组 $a$， 计算： 
$$
\sum\limits_{l = 1}^{n}{\sum\limits_{r = l}^{n}{a_l \oplus a_{l + 1} \oplus \cdots \oplus a_r}}
$$

**数据范围：** $1 \le n \le 10^5$，$0 \le a_i \le 10^9$。

#### 思路1
设 $b$ 为 $a$ 数组的前缀异或和数组（即：$b_i = \bigoplus\limits_{j = 1}^{i}{a_i}$），将题目转化为：
$$
\sum\limits_{l = 0}^{n}{\sum\limits_{r = l + 1}^{n}{b_l \oplus b_r}}
$$

我们假设 $b_i \in \{0, 1\}$，那么上面的式子只有 $b_l$ 和 $b_r$ 其中一个是 $0$，其中一个是 $1$，才会产生贡献。所以对于这种情况的答案就是 $cnt0 \times cnt1$ （注：$cnt0$ 表示 $b$ 数组中 $0$ 的个数， $cnt1$ 表示 $b$ 数组中 $1$ 的个数）。

因为异或操作二进制的位与位之间没有任何关联，所以我们按位处理，这样就可以按照上面说的方法做了。时间复杂度 $O(n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MAXN = (int)1e5 + 5;

int n;
int a[MAXN], pre[MAXN]; // 前缀异或和数组

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        pre[i] = pre[i - 1] ^ a[i];
    }

    ll ans = 0;
    for (int i = 0; i <= 31; i++) {
        int cnt0 = 0, cnt1 = 0;
        for (int j = 0; j <= n; j++) {
            if ((pre[j] >> i) & 1) cnt1++;
            else cnt0++;
        }
        ans += (1ll << i) * cnt1 * cnt0;
    }
    cout << ans << "\n";
    
    return 0;
}
```

#### 思路2
考虑枚举 $r$，发现前面可能的 $r$ 个 $l$ 成三角形，如下：
```
      r (l = r)
     lr
    l-r
   l--r
  l---r
 l----r
```

设当前枚举右端点为 $r$，设 $s_j$ 表示 $r$ 之前的所有区间的二进制第 $j$ 位 $1$ 的数量。当 $a_i$ 的第 $j$ 位为 $1$，贡献为之前所有区间 $0$ 的个数，即 $s_j = i - s_j$。

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MAXN = (int)1e5 + 5;

int n;
int a[MAXN], s[MAXN];

int main() {
    cin >> n;
    ll ans = 0;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= 30; j++) {
            if ((a[i] >> j) & 1) s[j] = i - s[j];
            ans += (ll)s[j] * (1ll << j);
        }
    }
    cout << ans << "\n";

    return 0;
}
```

### CF1879D Sum of XOR Functions
#### 题目描述

计算：
$$
\sum\limits_{l = 1}^{n}{\sum\limits_{r = l}^{n}{f(l, r) \times (r - l + 1)}}
$$
结果对 $998244353$ 取模的结果，其中 $f(l, r)$ 表示 $a_l \oplus a_{l+1} \oplus \cdots \oplus a_{r}$。

**数据范围:** $1 \le n \le 3 \cdot 10^5$，$0 \le a_i \le 10^9$。

#### 思路
考虑按照 [P3917](https://www.luogu.com.cn/problem/P3917) 的思路1的想法。

设 $b$ 为 $a$ 数组的前缀异或和数组（即：$b_i = \bigoplus\limits_{j = 1}^{i}{a_i}$），将题目转化为：
$$
\sum\limits_{l = 0}^{n}{\sum\limits_{r = l + 1}^{n}{(b_l \oplus b_r) \times (r - l)}}
$$

假设 $b_i \in \{0, 1\}$，对于第 $i$ 个数，答案就是前面所有值为 $\text{\textasciitilde}b_i$ 到 $i$ 的距离之和。我们预处理一个 $sum_{0/1}$ 数组表示 $i$ 之前（包括 $i$）前缀异或和为 $0/1$ 的数到 $i$ 的下标差之和，和一个 $cnt_{0, 1}$ 数组表示 $i$ 之前（包括 $i$）前缀异或和为 $0/1$ 的数的个数。假设当前的前缀疑惑和为 $x$，那么当前这一个数的 $sum_{x}$ 就为 $sum_{x} + cnt_{x}$，当前这一个数的贡献就是 $sum_{\text{\textasciitilde} x}$。



```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MAXN = (int)3e5 + 5;
const int MOD = 998244353;

int n;
ll a[MAXN], pre[MAXN];

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        pre[i] = pre[i - 1] ^ a[i];
    }

    ll ans = 0;
    for (int i = 0; i <= 30; i++) {
        ll cnt[2] = {0, 0}; // cnt[j]: j之前（包括j）pre为0/1的个数
        ll sum[2] = {0, 0}; // sum[j]: j之前（包括j）pre为0/1到j的下标差之和
        for (int j = 0; j <= n; j++) {
            // 更新（延伸）之前的下标差
            sum[0] = sum[0] + cnt[0];
            sum[0] %= MOD;
            sum[1] = sum[1] + cnt[1];
            sum[1] %= MOD;
            if ((pre[j] >> i) & 1) cnt[1]++; // 当前是1
            else cnt[0]++; // 当前是0
            // 更新贡献
            if ((pre[j] >> i) & 1) ans += sum[0] * (1ll << i);
            else ans += sum[1] * (1ll << i);
            ans %= MOD;
        }
    }
    cout << ans << "\n";

    return 0;
}
```