# 最近公共祖先

$\rm LCA$ 最近公共祖先，定义是树上两个点向根方向的第一个相遇点。我们通常使用 $\rm LCA$ 来求树上两个点之间的关系（如距离）。如何快速求出最近公共祖先？这里会介绍 $4$ 种方法。

注：假设我们需要求出 $u$ 到 $v$ 的 $\rm LCA$，假设这个 $\rm LCA$ 为 $w$。

## 朴素算法
### 思路
对于一棵树，我们定义 $dep_i$ 表示节点 $i$ 到根的距离（也就是深度），而 “向上移动” 表示往根节点方向移动。更具定义，我们很容易想到两个点同时向上移动，但是由于 $dep_u$ 可能不等于 $dep_v$，这导致两个点可能不会同时到达点 $w$。所以我们考虑先让深度更深的向上移动，直到 $u$ 和 $v$ 两点深度相同。这样向上同时移动就一定可以同时到达 $w$ 了。

### Code
为了计算这个 $w$，我们需要初始化一个 $fa$ 数组和 $dep$ 数组，分别表示这个点向根方向移动一步的节点编号（也就是这个点到父亲的编号）和这个点到根的距离（也就是深度）。

下面展示核心代码：
```cpp
void initlca(int u, int last) {
    fa[u] = last;
    dep[u] = dep[last] + 1;
    for (int v : g[u]) {
        if(v != last) initlca(v, u);
    }
}

int lca (int u, int v) {
    if(dep[u] < dep[v]) swap(u, v);
	while (dep[u] > dep[v]) u = fa[u];
	if (u == v) return u;
	while (u != v) u = fa[u], v = fa[v];
	return u;
}
```
### 复杂度
预处理时间复杂度为 $O(n)$，单次查询时间复杂度 $O(n)$。

空间复杂度为 $O(n)$。

## 倍增法
朴素算法在多次查询在时间复杂度上具有极大劣势，所以考虑使用倍增优化。

### 思路
假设一个点 $x$，我们需要求出 $x$ 向上移动 $y$ 次后的点，我们可以将 $y$ 转二进制数组 $z$，使得 $z_0 \times 2^0 + z_1 \times 2^1 + \cdots + z_{\log_2(n)} \times 2^{\log_2(n)} = y$，如果 $z_i = 1$ 向上移动 $2^i$ 次。这样我们就可以仅操作 $\log_2(y)$ 次使得 $x$ 向上移动 $y$ 次。

我们可以预处理出一个 $fa$ 数组，$fa_{i, j}$ 表示点 $i$ 向上移动 $2^j$ 次后到达的点。

朴素算法的核心思想是先将 $u$ 和 $v$ 调整到深度相同，然后同时向上移动。而我们可以使用上面说的二进制拆分结合 $fa$ 数组快速实现。

### Code
#### 预处理的改变
预处理只修改了 $fa$ 数组，所以这里只将 $fa$ 数组的预处理，预处理 $fa$ 数组如下：
```cpp
fa[u][0] = f;
for (int i = 1; i <= 30; i++) {
    fa[u][i] = fa[fa[u][i - 1]][i - 1];
}
```
首先先初始化这个点的父亲所以 $fa_{u, 0} = f$，然后我们想求出向上跳 $2^i$ 次方的祖先是谁可以使用 $2^{i - 1} + 2^{i - 1}$ 算出，所以 $fa_{u, i} = fa_{fa_{u, i - 1}, - 1}$。

#### LCA函数的改变


### 复杂度

## 欧拉序 + ST表
## Dfn序 + ST表
## 例题

- <a href="https://www.luogu.com.cn/problem/P3379" target="_blank">P3379 【模板】最近公共祖先（LCA）</a>
- <a href="https://www.luogu.com.cn/problem/P10113" target="_blank">P10113 大量的工作沟通）</a>