# Day 1
## 上午（单调队列）
### P1886 滑动窗口/【模板】单调队列
#### 思路
- 这题直接使用单调队列即可。
- 单调队列不一定是使用 `deque` ，也可以手动模拟。
#### Code
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = (int)1e6 + 5;

int n, k;
int head, tail;
int a[MAXN], q[MAXN];

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	
	cin >> n >> k;
	for (int i = 1; i <= n; i++) cin >> a[i];
	
	head = 1, tail = 0;
	for (int i = 1; i <= n; i++) {
		if (head <= tail && q[head] < i - k + 1) head++;
		while (head <= tail && a[q[tail]] > a[i]) tail--;
		q[++tail] = i;
		if (i >= k) cout << a[q[head]] << " ";
	}
	cout << "\n";
	
	head = 1, tail = 0;
	for (int i = 1; i <= n; i++) {
		if (head <= tail && q[head] < i - k + 1) head++;
		while (head <= tail && a[q[tail]] < a[i]) tail--;
		q[++tail] = i;
		if (i >= k) cout << a[q[head]] << " ";
	}
	cout << "\n";
	
	return 0;
}
```

### P3422 [POI 2005] LOT-A Journey to Mars
#### 思路
- 有环，所以破环成链。
- 假如当前从第 $u$ 好点出发，我们必须时刻满足 $\sum{}^{}{p_i} > \sum{}^{}{d_i}$，也就是 $\min(\sum{}^{}{p_i} - \sum{}^{}{d_i}) \ge 0$ 。看到求和符号就直接想到预处理前缀和。
- 发现式子里有 $\min$ ，所以可以使用单调队列维护一个长度为 $n$ 的滑动窗口。
- 注意要考虑全面，顺时针和逆时针都有可能，所以需要做正反两遍。
#### Code
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MAXN = (int)1e6 + 5;

int n;
ll p[MAXN * 2], d[MAXN * 2];
int q[MAXN * 2], head, tail;
ll pre[MAXN * 2]; // 这里代表的值是 p[]-d[] 的前缀和
bool ans[MAXN]; // 从这个点触犯是否满足题目要求

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> p[i] >> d[i];
		p[i + n] = p[i];
		d[i + n] = d[i];
	}
	
	for (int i = 1; i <= 2 * n; i++) pre[i] = pre[i - 1] + (p[i] - d[i]);
	
	// 1.顺时针走的情况
	head = 0, tail = -1;
	for (int i = n * 2; i >= 1; i--) {
		while (head <= tail && pre[q[head]] >= pre[i]) tail--;
		q[++tail] = i;
		if (head <= tail && q[head] >= i + n) head++;

		if (i <= n) {
			if (pre[q[head]] - pre[i - 1] >= 0) ans[i] = true;
		}
	}
	
	// 2.逆时针走的情况
	d[0] = d[n];
	for (int i = 1; i <= 2 * n; i++) pre[i] = pre[i - 1] + p[i] - d[i - 1];

	head = 0, tail = -1;
	for (int i = 1; i <= 2 * n; i++) {
		while (head <= tail && pre[q[tail]] <= pre[i]) tail--;
		q[++tail] = i;
		if (head <= tail && q[head] < i - n) head++;
		if (i >= n) {
			if (pre[i] - pre[q[head]] >= 0) ans[i - n] = true;
		}
	}
	
	for (int i = 1; i <= n; i++) {
        if (ans[i]) cout << "TAK\n";
        else cout << "NIE\n";
	}
	
	return 0;
}
```

### P4269 [USACO18FEB] Snow Boots G
#### 思路
对于一个可以承受最多 $s$ 英尺深的靴子都不能停留的位置，承受度在 $s$ 以下的靴子也肯定不能停留。所以如果靴子从高到低排序，那么靴子去不了的地方的数量是严格不下降的。所以这形成了单调性。

我们将所有数据离线处理，将雪的高度从高到小排序（这里只需要从 $2$ 到 $n - 1$ 排序即可，因为 $1$ 和 $n$ 为 $0$ ）。靴子按照最大承受度从大到小排序。每次处理出有多少个点在这一轮这个靴子去不了（这里可以使用 `while` 循环处理）。然后这里使用 **并查集** ~~想不到吧~~ 处理出在原图最大的去不了的连通块的大小，**当在原图里形成大于自己的步长的不能去的连通块，说明自己跨不过去。**

最后记着按照原顺序输出。
#### Code
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = (int)1e5 + 5;
const int MAXB = (int)1e5 + 5;

int n, b;
int vis[MAXN], maxn;
int fa[MAXN], siz[MAXN];
struct Snow {
	int s, id;
} f[MAXN];
struct Boot {
	int s, d, id;
	bool ans;
} g[MAXB];

int findr(int x) {
	if (fa[x] == x) return x;
	return fa[x] = findr(fa[x]);
}
bool merge(int x, int y) {
	int rx = findr(x), ry = findr(y);
	if (rx == ry) return false;
	
	fa[ry] = rx;
	siz[rx] += siz[ry];
	maxn = max(maxn, siz[rx]);
	return true;
}
void init() {
	for (int i = 1; i <= n; i++) {
		fa[i] = i;
	}
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	
	cin >> n >> b;
	for (int i = 1; i <= n; i++) {
		cin >> f[i].s;
		f[i].id = i;
	}
	for (int i = 1; i <= b; i++) {
		cin >> g[i].s >> g[i].d;
		g[i].id = i;
	}

	sort(f + 2, f + n, [](const Snow &u, const Snow &v) { // 这里只排序 [2, n - 1]
		return u.s > v.s;
	});
	sort(g + 1, g + b + 1, [](const Boot &u, const Boot &v) {
		return u.s > v.s;
	});

	init();
	int j = 2; // 从2开始因为题目说1和n都为0
	for (int i = 1; i <= b; i++) {
		while (g[i].s < f[j].s) {
			// 合并
			int fid = f[j].id;
			vis[fid] = 1;

			maxn = max(maxn, 1);
			siz[fid] = 1;
			
			if (vis[fid - 1]) merge(fid, fid - 1);
			if (vis[fid + 1]) merge(fid, fid + 1);
			j++;
		}
		g[i].ans = (g[i].d > maxn ? 1 : 0);
	}

	sort(g + 1, g + b + 1, [](const Boot &u, const Boot &v) {
		return u.id < v.id;
	});
	for (int i = 1; i <= b; i++) cout << g[i].ans << "\n";
	
	return 0;
}
```

## 下午（单调性分析）
### P3089 [USACO13NOV] Pogo-Cow S
#### 思路
~~之前暴力直接过了，没有想正解~~

设 $dp_{j, i}$ 表示从 $j$ 跳到 $i$ 的最大可能得分，然后考虑枚举一个点 $k$， 是的 $dp_{j, i}$ 是从 $dp_{k, j}$ 转移而来。由于我们需要从前面最大的转移而来。

如果枚举的顺序是这样：
```cpp
for (int i = ......) {
	for (int j = ......) {
		for (int k = ......) {
		
		}
	}
}
```
那么满足条件的转移的数量是成抛物线状的（一直增加到了一个顶峰，然后一直减少）

如果枚举顺序是这样：
```cpp
for (int j = ......) {
	for (int i = ......) {
		for (int k = ......) {
		
		}	
	}
}
```
那么满足条件的战役的数量是严格不下降的，满足单调性，所以可以存一个 $val$ 表示 $dp_{k, j}$ 的最大值，然后转移即可。

#### Code
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MAXN = 1000 + 5;

int n, ans = 0;
int dp[MAXN][MAXN]; // dp[j][i]: 从j到i的答案
struct E {
    int x, p;
} g[MAXN];

void find_ans() {
    for (int i = 0; i <= n + 1; i++) 
        for (int j = 0; j <= n + 1; j++) 
            ans = max(ans, dp[i][j]);
}
void init() {
    for (int i = 0; i <= n + 1; i++) 
        for (int j = 0; j <= n + 1; j++) 
            dp[i][j] = 0;
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> g[i].x >> g[i].p;
    sort(g + 1, g + n + 1, [](const E &u, const E &v) {
        return u.x < v.x;
    });

    for (int i = 1; i <= n; i++) dp[i][i] = g[i].p;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j < i; j++) {
            for (int k = 1; k <= j; k++) {
                int dis1 = g[i].x - g[j].x + 1, dis2 = g[j].x - g[k].x + 1;
                
                if (dis1 >= dis2) dp[i][j] = max(dp[i][j], dp[j][k] + g[i].p);
            }
        }
    }
    find_ans();

    init();
    for (int i = 1; i <= n; i++) dp[i][i] = g[i].p;
    for (int i = n; i >= 1; i--) {
        for (int j = n; j > i; j--) {
            for (int k = n; k >= j; k--) {
                int dis1 = g[j].x - g[i].x + 1, dis2 = g[k].x - g[j].x + 1;
                
                if (dis1 >= dis2) dp[i][j] = max(dp[i][j], dp[j][k] + g[i].p);
            }
        }
    }
    find_ans();

    cout << ans << "\n";

    return 0;
}
```

### P1545 [USACO04DEC] Dividing the Path G
#### 思路
定义 $dp_i$ 表示铺满 $[1, i]$ 的所有草地最少使用多少个喷灌器（且喷灌范围不重叠）。由于奶牛的范围之间只能有 $1$ 中喷灌器，所以我们只可以在奶牛的端点进行转移（因为在奶牛范围内且不在端点，必定出现大于 $1$ 种喷灌器，~~不行自己画画~~），而且这里可以使用差分判断。

所以最后我们求的就是 $dp_i = \min\limits_{j = i - 2b}^{2a}{dp_j}$。发现 $\min$ 且满足单调性，所以使用单调队列优化。
#### Code
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = (int)1e3 + 5;
const int MAXL = (int)1e6 + 5;

int n, l, a, b;
int diff[MAXL], dp[MAXL];
int q[MAXL], head, tail;

int main() {
    cin >> n >> l;
    cin >> a >> b;
    for (int i = 1; i <= n; i++) {
        int s, e;
        cin >> s >> e;
        diff[s + 1]++;
        diff[e]--;
    }
    for (int i = 1; i <= l; i++) {
        diff[i] += diff[i - 1];
        dp[i] = (int)1e9;
    }

    head = 1, tail = 0;
    dp[0] = 0;
    for (int i = a * 2; i <= l; i++) { // 开始是 a*2 因为最小是 a*2 的喷灌器
        while (head <= tail && dp[i - a * 2] < dp[q[tail]]) tail--;
        q[++tail] = i - a * 2;
        while (head <= tail && q[head] < i - b * 2) head++; // 最大的喷灌器为 b*2

        // 如果当前在某一奶牛区间内，或者为奇数时，肯定没有办法设置喷灌器来满足要求。
        if (diff[i] || i % 2 == 1) continue;
        if (dp[q[head]] != (int)1e9) dp[i] = dp[q[head]] + 1;
    }
    if (dp[l] == (int)1e9) cout << "-1\n";
    else cout << dp[l] << "\n";

    return 0;
}
```

---
# Day 2
## 上午（模拟赛）
### T1：P13286 [GCJ 2013 #1A] Manage your Energy
#### 思路
 分两种情况：
1. 这个点后面没有更大的
2. 后面有比自己更大的
	1. $cur + kr \le E$
	2. $cur + kr > E$

- 初始化 $nxt$ 数组。（使用单调栈/单调队列维护单调递减，也就是后面第一个比我高的点）
- 注意特判 $R \ge E$ 的情况
#### Code
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MAXN = (int)1e4 + 5;
const int MAXE = (int)1e7 + 5;

ll e, r, n;
ll v[MAXN];
int nxt[MAXN];
int stk[MAXN], stktop;

void sol(int id) {
    cin >> e >> r >> n;
    for (int i = 1; i <= n; i++) {
        cin >> v[i];
        nxt[i] = -1;
    }

    if (r >= e) { // 特判：说明每次都能恢复到满的值
        ll ans = 0;
        for (int i = 1; i <= n; i++) ans += e * v[i];
        cout << "Case #" << id << ": " << ans << "\n";
        return ;
    }

    stktop = 0;
    for (int i = 1; i <= n; i++) {
        while (stktop && v[stk[stktop]] < v[i]) {
            nxt[stk[stktop]] = i;
            stktop--;
        }
        stk[++stktop] = i;
    }

    ll ans = 0, cur = e;
    for (int i = 1; i <= n; i++) {
        if (nxt[i] == -1) { // 后面没有比自己更大的值了
            ans += cur * v[i];
            cur = 0;
        } else {
            ll k = (nxt[i] - i);
            if (cur + k * r > e) { // 情况2，情况1不考虑
                ll tmp = min(cur, cur + k * r - e);
                ans += v[i] * tmp;
                cur -= tmp;
            }
        }
        cur += r; // 每次恢复r能量
        if (cur > e) cur = e;
    }
    cout << "Case #" << id << ": " << ans << "\n";
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    int T;
    cin >> T;
    for (int i = 1; i <= T; i++) {
        sol(i);
    }

    return 0;
}
```

### T2：P12501 「ROI 2025 Day1」奥林匹克楼梯
#### 思路
- $a_{i,j}$ ：这个点往上连续的 $1$ 的长度，在每次输入的时候可以预处理。
- 我们考虑从前往后和从后往前两种求答案的方式。
- 如果从前往后，遇到更高的不知道是另起一段还是继续这个一个楼梯（把这个更高的变成当前需要的）。
- 所以我们考虑从后往前，这样遇到一个比自己矮的就必须按照这个矮的继续，我们可以使用单调栈来维护第一个比自己小的地方。发现有比自己小的时候就更新答案。
- 可以使用滚动数组，或者 `vector` 存图。
#### Code
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXM = (int)2e5 + 5;

int n, m;
int pre[MAXM], sum[MAXM], stk[MAXM], stktop;

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n >> m;
    int ans = 0;
    stk[0] = m + 1;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            char c;
            cin >> c;
            if (c == '1') pre[j]++;
            else pre[j] = 0;
        }

        stktop = 0;
        for (int j = m; j >= 1; j--) {
            while (stktop && pre[j] < pre[stk[stktop]]) {
                ans = max(ans, sum[stk[stktop]]);
                stktop--;
            }
            sum[j] = sum[stk[stktop]] + (stk[stktop] - j) * pre[j];
            stk[++stktop] = j;
        }
        while (stktop) ans = max(ans, sum[stk[stktop--]]);
    }
    cout << ans << "\n";

    return 0;
}
```

### T3：P3869 [TJOI2009] 宝藏
#### 思路
- 注意数据范围：$5 \le r, c \le 30$，$0 \le k \le 10$，$1 \le r_i, R_i \le r$，$1 \le c_i, C_i \le c$。
- 这题可以 `bfs` 暴搜索
- 发现 $k \le 10$ ，所以使用状压，定义一个变量 $f$ 范围在 $1 \le 2^{10}$ ，如果 $i$ 个机关被触发，那么直接 $f \oplus i$ 即可。
#### Code
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXNM = 30 + 5;
const int MAXK = 10;

int n, m;
int sx, sy, ex, ey;
int vis[MAXNM][MAXNM][1 << MAXK];
int dir[5][2] = {{0, 0}, {1, 0}, {-1, 0}, {0, -1}, {0, 1}};
char g[MAXNM][MAXNM];
struct E {
    int u, v, x, y;
} t[MAXNM];

struct Q {
    int x, y, step;
    int code;
};
queue<Q> q;

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> g[i][j];
            if (g[i][j] == 'S') {
                sx = i, sy = j;
                g[i][j] = '.';
            } else if (g[i][j] == 'T') {
                ex = i, ey = j;
                g[i][j] = '.';
            }
        }
    }

    int k;
    cin >> k;
    for (int i = 1; i <= k; i++) {
        cin >> t[i].u >> t[i].v >> t[i].x >> t[i].y;
    }

    q.push({sx, sy, 0, 0});
    while (!q.empty()) {
        int x = q.front().x;
        int y = q.front().y;
        int step = q.front().step;
        int code = q.front().code;
        q.pop();

        if (x == ex && y == ey) {
            cout << step << "\n";
            return 0;
        }

        for (int i = 1; i <= 4; i++) {
            int nx = x + dir[i][0];
            int ny = y + dir[i][1];
            int ncode = code;
            
            if (nx < 1 || ny < 1 || nx > n || ny > m) continue;

            bool flag = false;
            for (int j = 1; j <= k; j++) {
                if (t[j].x == nx && t[j].y == ny && code & (1 << j)) flag ^= 1;
                if (t[j].u == nx && t[j].v == ny) ncode ^= (1 << j);
            }
            if ((g[nx][ny] == '.' && flag) || (g[nx][ny] == '#' && !flag)) continue;
            if (vis[nx][ny][ncode]) continue;
            
            vis[nx][ny][ncode] = 1;
            q.push({nx, ny, step + 1, ncode});
        }
    }
    cout << "-1\n";

    return 0;
}
```

## 下午（区间DP）
### 区间 DP
- 技巧：区间从小到大转移，所有区间从最小区间入手。

### B4336 永别
#### 思路
注意数据范围：$len \le 1000$ ，这非常小，我们不妨考虑 区间 $DP$。

假设 $dp_{i, j}$ 表示 $i$ 到 $j$ 的中的最长回文子序列，$s$ 为字符串

- 当 $i = j$ 时，$dp_{i,j} = 1$。
- 当 $j - i \ge 2$ 时
	- 当 $s_i = s_j$，$dp_{i, j} = dp_{i + 1, j - 1} + 2$。
	- 当 $s_i \not = s_j$，$dp_{i, j} = \max(dp_{i + 1, j}, dp_{i, j - 1})$
#### Code
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1000 + 5;

int n;
int dp[MAXN][MAXN];
char s[MAXN];

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> s[i];
        dp[i][i] = 1;
    }
    for (int len = 2; len <= n; len++) {
        for (int i = 1; i <= n - len + 1; i++) {
            int j = i + len - 1;

            if (s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1] + 2;
            else dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
        }
    }

    cout << dp[1][n] << "\n";

    return 0;
}
```
### P10115 Placer
#### 思路
注意数据范围：$1 \le n \le 3 \times 10^6$，有些大，但是我们还是可以继续考虑区间 $DP$。

假设 $dp_i$ 表示 $1$ 到 $i$ 的答案。我们可以预处理出与 $i$ 匹配的括号 $lst_i$ 。在 $DP$ 时出现以下两种情况：

- 当 $dp_i =$ `(`，那么 $dp_i = dp_{i - 1}$。
- 当 $dp_i =$ `)`，分为以下两种情况：
	 - $i$ 不需要匹配，$dp_i = dp_{i - 1}$
	 - $i$ 需要匹配，这个点需要从某一可以与 $i$ 匹配的点 $k$  转移而来，且中途不可以有不符合要求的分段，即：$dp_i = dp_{k - 1} + (w_i - w_k)$。

		如果我们枚举这个 $k$ ，显然会超时。我们观察式子后发现可以整理成这样：$dp_i = (dp_{k - 1} - w_k) + w_i$ ，这样我们就可以将一个确定 $dp_i$ 拿出来，处理 $dp_{k - 1} + w_k$ 了。由于要求 $dp_i$ 的最大值，所以只需要求出 $dp_{k - 1} - w_k$ 的最大值了。

		我们定义 $f_i$ 为 $i$ 往前最长连续合法的分段中 $dp_{k - 1} - w_k$ 的最大值，然后每一步处理就可以了。
#### Code

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MAXN = (int)3e6 + 5;

int n;
int a[MAXN], lst[MAXN];
int stk[MAXN], stktop; // 算出括号匹配的对象
ll dp[MAXN], f[MAXN];
char s[MAXN];

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n;
    for (int i = 1; i <= n; i++) cin >> s[i];
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        if (s[i] == '(') stk[++stktop] = i;
        else if (stktop) lst[i] = stk[stktop--];
    }

    for (int i = 0; i <= n; i++) dp[i] = f[i] = -(ll)1e18; // 记着从0初始化
    dp[0] = 0;
    for (int i = 1; i <= n; i++) {
        dp[i] = dp[i - 1];
        if (lst[i]) {
            f[i] = max(f[lst[i] - 1], dp[lst[i] - 1] - a[lst[i]]);
            dp[i] = max(dp[i], f[i] + a[i]);
        }
    }
    cout << dp[n] << "\n";

    return 0;
}
```
### P5851 Greedy Pie Eaters P
#### 思路
- $1 \le n \le 300$，考虑区间 $DP$。

我们设 $dp_{i, j}$ 表示 $i$ 到 $j$ 区间给牛吃满足题目要求时最大体重和。我们很容易想到以下转移：
```cpp
for (int k = i; k < j; k++) {
	dp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j]);
}
```

但是这样二分化全面吗？其实并不全面（但是是必要的）。我们如果想让一头新的牛吃一个范围，上面的转移并不能满足。因为只要这一头牛的范围内有一个草没被吃，那么它就可以吃。

为了让新的奶牛可以吃这个草，我们枚举第 $k$ 个草专门给新的奶牛吃，然后转移就变成了如下：
```cpp
for (int k = i; k < j; k++) { // 虽然这个转移不全面，但是是有必要的。
	dp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j]);
}
for (int k = i + 1; k < j; k++) {
	dp[i][j] = max(dp[i][j], dp[i][k - 1] + dp[k + 1][j] + 新的牛的体重);
}
```

那么我们就可以预处理出一个 $g$ 数组，$g_{i, j, k}$ 表示区间包括 $k$ 这个点，且吃草区间在 $[i, j]$ 的奶牛的体重的最大值。这时 $g_{i, j, k}$ 的转移如下：
```cpp
for (int k = i; k <= j; k++) {
	dp[i][j] = max(dp[i + 1][j][k], dp[i][j - 1][k]);
}
```
#### Code
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 300 + 5;
const int MAXM = 45000 + 5;

int n, m;
int g[MAXN][MAXN][MAXN]; // 所有某一点在 k 上面的牛，并且这头牛的范围在[i,j]之内的最大值。
int dp[MAXN][MAXN]; // [i,j] 的答案

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int u, v, w;
        cin >> w >> u >> v;

        for (int j = u; j <= v; j++) {
            g[u][v][j] = w; // 题目有说任意俩区间都不一样，所以直接覆盖就好（一定有某一点不一样）
        }
    }
    
    for (int len = 2; len <= n; len++) {
        for (int i = 1; i <= n - len + 1; i++) {
            int j = i + len - 1;
            for (int k = i; k <= j; k++) {
                g[i][j][k] = max({g[i][j][k], g[i + 1][j][k], g[i][j - 1][k]});
            }
        }
    }
    for (int i = 1; i <= n; i++) dp[i][i] = g[i][i][i];
    for (int len = 2; len <= n; len++) {
        for (int i = 1; i <= n - len + 1; i++) {
            int j = i + len - 1;
            for (int k = i; k < j; k++) {
                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j]);
            }
            for (int k = i; k <= j; k++) {
                dp[i][j] = max(dp[i][j], dp[i][k - 1] + dp[k + 1][j] + g[i][j][k]);
            }
        }
    }
    cout << dp[1][n] << "\n";

    return 0;
}
```

### P4302 字符串折叠
#### 思路
- 字符串长度 $\le 100$ ，我们可以考虑区间 $DP$

$dp_{i,j}$ 表示折叠后的区间 $[i, j]$ 的最短长度。我们考虑两种情况。
- 本身不折叠，由两个区间转移而来，即：$dp_{i,j} = min(dp_{i,j}, dp_{i, k} + dp_{k + 1,j})$
- 本身折叠，那么一定有一个循环节 $len$ ，我们只需要写一个 `check` 函数来判断是否满足即可。
#### Code
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100 + 5;

int n;
int dp[MAXN][MAXN];
char s[MAXN];

bool check(int l, int r, int k) {
    for (int i = l + k; i <= r; i++) {
        if (s[i] != s[i - k]) {
            return false;
        }
    }
    return true;
}

int main() {
    string tmp;
    cin >> tmp;
    
    for (auto e : tmp) {
        n++;
        s[n] = e;
    }

    for (int i = 1; i <= n; i++) {
        for (int j = i; j <= n; j++) {
            dp[i][j] = (j - i + 1);
        }
    }
    
    for (int len = 2; len <= n; len++) {
        for (int l = 1; l <= n - len + 1; l++) {
            int r = l + len - 1;

            for (int k = l; k < r; k++) {
                dp[l][r] = min(dp[l][r], dp[l][k] + dp[k + 1][r]);
            }
            
            for (int k = 1; k <= len / 2; k++) {
                if (len % k != 0) continue;
                if (check(l, r, k)) {
                    string tmp = to_string(len / k);
                    dp[l][r] = min(dp[l][r], (int)tmp.size() + 2 + dp[l][l + k - 1]);
                }
            }
        }
    }

    cout << dp[1][n] << "\n";

    return 0;
}
```

---

# Day 3
## 上午 （最小生成树MST）
### P3366 【模板】最小生成树
#### 思路
`MST` 模板，最好使用 `Kruskal` 算法因为不用建图，`Prim` 其实也可以。
#### Code

### P3104 [USACO14MAR] Counting Friend G
#### 思路
- 给定 $n + 1$ 个点，给定每个点的度数，求一些点，满足删除这个点和相邻的边后，图变为联通图。
- 对于度数小的边，我们如果有优先处理，那么到后面可能会出现一种情况：某一个点没有边可以连。所以我们优先处理边最多的点，让第一大的点跟第二大的点连，如果最后发现有几个点还有边没有连，那么这个点就是其中一个答案。
#### Code
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 500 + 5;

int n;
int a[MAXN], b[MAXN], ti;
vector<int> ans;

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n;
    n++;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= n; i++) {
        ti = 0;
        for (int j = 1; j <= n; j++) {
            if (j != i) b[++ti] = a[j];
        }
        bool flag = true;
        sort(b + 1, b + ti + 1, greater<int>());
        while (ti) {
            int tail = 2;
            while (b[1] && b[tail]) {
                b[1]--; b[tail]--;
                tail++;
            }
            if (b[1]) {
                flag = false;
                break;
            }
            sort(b + 1, b + ti + 1, greater<int>());
            ti--; // 每一轮都会有一个值变成0，所以ti--
        }
        if (flag) ans.push_back(i);
    }

    sort(ans.begin(), ans.end());
    cout << ans.size() << "\n";
    for (auto u : ans) cout << u << "\n";

    return 0;
}
```

## 下午（最近公共祖先LCA）
### P3379 【模板】最近公共祖先（LCA）
#### 思路
- 数据范围不允许我们暴力一格一格网上跳，所以可以使用倍增  $LCA$ ，单次查询时间复杂度 $O(\log{n})$ 。
- 这题其实也可以使用 **欧拉序 + $ST$ 表解决** 或者 **$dfn$ 序 + $ST$ 表** 解决，这样单词查询时间复杂度为 $O(1)$。
#### Code
这里放三分代码，分别是倍增版的 $LCA$，欧拉序  + $ST$ 表版的 $LCA$，和 $dfn$ 需 + $ST$ 表版的 $LCA$。

##### 倍增版 LCA
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 5e5 + 5;
int n, m, root;
int deep[MAXN], fa[MAXN][35];
vector<int> g[MAXN];

void dfs(int u, int last) {
    fa[u][0] = last;
    deep[u] = deep[last] + 1;
    for (int i = 1; i <= 30; i++) 
        fa[u][i] = fa[fa[u][i - 1]][i - 1];

    for (int v : g[u]) {
        if(v != last) dfs(v, u);
    }
}

int lca (int u, int v) {
    if(deep[u] < deep[v]) swap(u, v);
    int tmp = deep[u] - deep[v];

    for (int i = 30; i >= 0; i--) {
        if (deep[fa[u][i]] >= deep[v]) {
            u = fa[u][i];
        }
    }

    if(u == v) return u;

    for (int i = 30; i >= 0; i--) {
        if(fa[u][i] ^ fa[v][i]) {
            u = fa[u][i];
            v = fa[v][i];
        }
    }

    return fa[u][0];
}

int main() {
	cin >> n >> m >> root;
	for (int i = 1; i < n; i++) {
		int u, v;
		cin >> u >> v;

        g[u].push_back(v);
        g[v].push_back(u);
	}

    dfs(root, 0);
    
    for (int i = 1; i <= m; i++) {
        int a, b;
        cin >> a >> b;

        cout << lca(a, b) << "\n";
    }

	return 0;
}
```
##### 欧拉序 + ST表版 LCA
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = (int)5e5 + 5;

int n, m, s;
int dfn[MAXN], euler[MAXN * 2], dep[MAXN], fa[MAXN], ti;
pair<int, int> st[21][MAXN * 2];
vector<int> g[MAXN];

void initlca(int u, int f) {
    dfn[u] = ++ti;
    euler[ti] = u;
    dep[u] = dep[f] + 1;
    fa[u] = f;
    for (auto v : g[u]) {
        if (v == f) continue;
        initlca(v, u);
        euler[++ti] = u;
    }
}
void initst() {
    for (int i = 1; i <= ti; i++) st[0][i] = {dep[euler[i]], euler[i]};
    for (int k = 1; k <= __lg(ti); k++) {
        for (int i = 1; i + (1 << k) - 1 <= ti; i++) {
            st[k][i] = min(st[k - 1][i], st[k - 1][i + (1 << (k - 1))]);
        }
    }
}
int lca(int u, int v) {
    int ru = dfn[u], rv = dfn[v];
    if (ru > rv) swap(ru, rv);

    int k = __lg(rv - ru + 1);
    return min(st[k][ru], st[k][rv - (1 << k) + 1]).second;
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n >> m >> s;
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;

        g[u].push_back(v);
        g[v].push_back(u);
    }
    initlca(s, 0);
    initst();
    for (int i = 1; i <= m; i++) {
        int u, v;
        cin >> u >> v;

        cout << lca(u, v) << "\n";
    }

    return 0;
}
```
##### dfn序 + ST表版 LCA
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = (int)5e5 + 5;

int n, m, s;
int dfn[MAXN], dep[MAXN], fa[MAXN], ti;
pair<int, int> st[21][MAXN];
vector<int> g[MAXN];

void initlca(int u, int f) {
    dfn[u] = ++ti;
    dep[u] = dep[f] + 1;
    fa[u] = f;
    for (auto v : g[u]) {
        if (v == f) continue;
        initlca(v, u);
    }
}
void initst() {
    for (int i = 1; i <= n; i++) st[0][dfn[i]] = {dep[i], i};
    for (int k = 1; k <= __lg(n); k++) {
        for (int i = 1; i + (1 << k) - 1 <= n; i++) {
            st[k][i] = min(st[k - 1][i], st[k - 1][i + (1 << (k - 1))]);
        }
    }
}
int lca(int u, int v) {
    if (u == v) return u;
    if (dfn[u] > dfn[v]) swap(u, v);
    int nu = dfn[u] + 1, nv = dfn[v];
    int k = __lg(nv - nu + 1);
    int id = min(st[k][nu], st[k][nv - (1 << k) + 1]).second;
    return fa[id];
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n >> m >> s;
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;

        g[u].push_back(v);
        g[v].push_back(u);
    }
    initlca(s, 0);
    initst();

    for (int i = 1; i <= m; i++) {
        int u, v;
        cin >> u >> v;

        cout << lca(u, v) << "\n";
    }

    return 0;
}
```

### P9235 [蓝桥杯 2023 省 A] 网络稳定性
#### 思路
- 我们想要让边权最小的边最大，而有一些边是浪费的（有更好的选择），所以我们跑一遍最大生成树。
- 跑完后发现就是求两个点之间的路径上边权最小值，由于树上两点路径唯一，所以我们可以预处理出一个祖先数组 $fa_{u, i}$ 和一个最小值数组 $minn_{u, i}$ ，然后使用 **倍增 + $LCA$** 就可以求出答案了。
- 第一次发现树上两点路径最小值可以预处理一个 $minn_{u, i}$ 数组，然后使用 **倍增 + $LCA$** 算出来诶！
#### Code
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef pair<int, int> pii;
const int MAXN = (int)1e5 + 5;
const int MAXM = (int)3e5 + 5;

int n, m;
int f[MAXN];
int dep[MAXN], fa[MAXN][21], minn[MAXN][21];
vector<pii> g[MAXN];
struct E {
    int u, v, w;
} e[MAXM];

int findr(int x) {
    if (f[x] == x) return x;
    return f[x] = findr(f[x]);
}
bool merge(int u, int v) {
    int ru = findr(u), rv = findr(v);
    if (ru == rv) return false;

    f[rv] = ru;
    return true;
}
void init() {
    for (int i = 1; i <= n; i++) f[i] = i;
}

void dfs(int u, int father) {
    dep[u] = dep[father] + 1;
    fa[u][0] = father;
    for (int i = 1; i <= 20; i++) {
        fa[u][i] = fa[fa[u][i - 1]][i - 1];
        minn[u][i] = min(minn[u][i - 1], minn[fa[u][i - 1]][i - 1]);
    }
    for (auto edge : g[u]) {
        int v = edge.first, w = edge.second;
        if (v == father) continue;

        minn[v][0] = w;
        dfs(v, u);
    }
}
int lca(int u, int v) {
    if (dep[u] < dep[v]) swap(u, v);
    int ans = (int)1e9;
    for (int i = 20; i >= 0; i--) {
        if (dep[fa[u][i]] >= dep[v]) {
            ans = min(ans, minn[u][i]);
            u = fa[u][i];
        }
    }
    if (u == v) return ans;
    for (int i = 20; i >= 0; i--) {
        if (fa[u][i] ^ fa[v][i]) {
            ans = min(ans, minn[u][i]);
            ans = min(ans, minn[v][i]);
            u = fa[u][i];
            v = fa[v][i];
        }
    }
    ans = min({ans, minn[u][0], minn[v][0]});
    return ans;
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    int Q;
    cin >> n >> m >> Q;
    for (int i = 1; i <= m; i++) cin >> e[i].u >> e[i].v >> e[i].w;
    sort(e + 1, e + m + 1, [](const E &u, const E &v) {
        return u.w > v.w;
    });
    
    init();
    for (int i = 1; i <= m; i++) {
        int u = e[i].u, v = e[i].v, w = e[i].w;
        if (merge(u, v)) {
            g[u].push_back({v, w});
            g[v].push_back({u, w});
        }
    }
    for (int i = 1; i <= n; i++) {
        if (!dep[i]) dfs(i, 0);
    }

    while (Q--) {
        int u, v;
        cin >> u >> v;

        if (findr(u) != findr(v)) cout << "-1\n";
        else cout << lca(u, v) << "\n";
    }

    return 0;
}
```

---

# Day 4
## 上午（模拟赛）
### T1：P4805 [CCC 2016] 合并饭团
#### 思路
- $1 \le n \le 400$ ，一看就是区间 $DP$。

设 $dp_{i, j}$ 表示区间 $[i, j]$ 的答案。按题意转移分以下两种情况：
- 两个相同的饭团合并
	- 假设 $dp_{i, k}$ 和 $dp_{k + 1, j}$ 大小相同，$dp_{i, j} = \max(dp_{i, j}, dp{i, k} + dp_{k + 1, j})$。
	- 这里注意枚举的两个饭团必须自己可以合并出来，否则不能进行转移。
- 两个相同的饭团中间夹着一个饭团合并
	- 我们枚举中间夹着的饭团的区间，注意去区间长度需从小到大，所以需枚举一个 `mlen`，然后计算出对应的区间 $[l, r]$，如果三个饭团都可以合并出来，且两边饭团大小一样，$dp_{i, j} = \max(dp_{i, l - 1} + dp_{l, r} + dp_{r + 1, j})$。
	- 这里注意三个饭团本身是必须可以合并出来才可以转移。
#### Code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 400 + 5;

int n;
int dp[MAXN][MAXN];

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> dp[i][i];
    }

	int ans = 0;
    for (int len = 1; len <= n; len++) {
        for (int i = 1; i <= n - len + 1; i++) {
            int j = i + len - 1;

            for (int k = 1; k < j; k++) {
                if (dp[i][k] == dp[k + 1][j] && dp[i][k]) dp[i][j] = max(dp[i][j], dp[i][k] * 2);
            }
            for (int mlen = 1; mlen <= len - 2; mlen++) {
                for (int l = i + 1; l <= j - mlen; l++) {
                    int r = l + mlen - 1;
                    if (dp[i][l - 1] == dp[r + 1][j] && dp[i][l - 1] && dp[l][r]) 
                        dp[i][j] = max(dp[i][j], dp[i][l - 1] + dp[r + 1][j] + dp[l][r]);
                }
            }
            ans = max(ans, dp[i][j]);
        }
    }
    cout << ans << "\n";

    return 0;
}
```

### T2：P5189 [COCI 2009/2010 #5] ZUMA
#### 思路
观察范围发现 $1 \le n \le 100$，考虑使用区间 $DP$。

设 $dp_{i, j}$ 表示消除区间 $[i, j]$ 最少添加的数量，**但是我们会发现一个问题，我们无法知道某个区间消除后还剩下什么，这导致我们可能会多添加一些数（`hack:121`）。**

我们设两维发现维护的不全面，所以考虑扩维。

设 $dp_{i, j, k}$ 表示消除区间 $[i, j]$ 以及 $j$ 后面与 $j$ 相同的 $k$ 个数（假如有），所需要的最小添加数量。我们枚举当前后面已经有了 $x$ 个与 $j$ 相同的数，这样就有了两种转移：
- $[i, j - 1]$ 自行消除，第 $j$ 个和 $j$ 后面的 $x$ 个数，总共 $x + 1$ 个数，这样我们需要添加 $\max(k - (x + 1), 0)$ 个数。
- 我们枚举一个 $p$，且满足 $p$ 和 $j$ 相同，就分为两个部分。前面的 $[i, p]$ 的贡献就是 $dp_{i, p, \min(x + 1, k - 1)}$（注意 $k$ 个数消除，所以需要取 $\min$ ），后面的贡献就是自行消除也就是 $dp_{p + 1, j, 0}$。

#### Code
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100 + 5;
const int MAXK = 5 + 5;

int n, K, a[MAXN];
int dp[MAXN][MAXN][MAXK]; // dp[i][j][k]: i 和 j 和 j后面的k个与j相同的数 消除所需要的最少次数。

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n >> K;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        for (int k = 0; k < K; k++) dp[i][i][k] = max(K - (k + 1), 0);
    }

    for (int len = 2; len <= n; len++) {
        for (int i = 1; i <= n - len + 1; i++) {
            int j = i + len - 1;
            for (int x = 0; x < K; k++) {
                dp[i][j][x] = dp[i][j - 1][0] + max(K - (x + 1), 0);
                for (int p = i; p < j; p++) {
                    if (a[p] == a[j])
                        dp[i][j][x] = min(dp[i][j][x], dp[i][p][min(x + 1, K - 1)] + dp[p + 1][j - 1][0]);
                }
            }
        }
    }

    cout << dp[1][n][0] << "\n";

    return 0;
}
```

### T3：P4951 [USACO01OPEN] Earthquake
#### 思路
假设我们选出了若干条边，$w_i$ 为 $0$ 表示不选第 $i$ 条边，为 $1$ 表示选第 $i$ 条边。那么收入 $f$ 元，总成本 $\sum\limits_{i = 1}^{m}{c_i w_i}$，总时间 $\sum\limits_{i = 1}^{n}{t_i w_i}$，最大化利润，即：$\frac{f - \sum\limits_{i = 1}^{m}{c_i w_i}}{\sum\limits_{i = 1}^{m}{t_i w_i}}$。

我们可以通过移项得到：
$$
ans = \frac{f - \sum\limits_{i = 1}^{m}{c_i w_i}}{\sum\limits_{i = 1}^{m}{t_i w_i}} \Longrightarrow ans \times \sum\limits_{i = 1}^{m}{t_i w_i} + \sum\limits_{i = 1}^{m}{c_i w_i} = f
$$


移项后的式子满足单调性，这样我们就可以二分这个 $ans$ 了。**单调性分析：如果 $ans$ 变大/变小，那么等式两边会同时变大/变小，满足二分所需的单调性。**

由于我们需要最小化 $ans \times \sum\limits_{i = 1}^{m}{t_i w_i} + \sum\limits_{i = 1}^{m}{c_i w_i}$ 所以每一条边的花费为：$ans \times t_i + c_i$ ，我们不搭建没有用的边，所以需要使用最小生成树来。最后判断选的边的花费总和和 $f$ 的关系，如果总花费 $> f$ 那么我们的利润为负数（我们不是傻子，这个生意还不如不做）那么 $ans$ 需要变小，否则需要变大。
#### Code

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef double db;
const int MAXN = 400 + 5, MAXM = 10000 + 5;

int n, m, fa[MAXN];
ll f;
struct Edge {
    int u, v;
    ll c, t;
    db cost;
} edge[MAXM];

int findr(int u) {
    if (fa[u] == u) return u;
    return fa[u] = findr(fa[u]);
}
bool merge(int u, int v) {
    int ru = findr(u), rv = findr(v);
    if (ru == rv) return false;

    fa[rv] = ru;
    return true;
}
void init() {
    for (int i = 1; i <= n; i++) fa[i] = i;
}

bool check(db mid) {
    for (int i = 1; i <= m; i++) edge[i].cost = mid * edge[i].t + edge[i].c;
    sort(edge + 1, edge + m + 1, [](const Edge &x, const Edge &y) {
        return x.cost < y.cost;
    });
    init();

    db ans = 0;
    for (int i = 1; i <= m; i++) {
        int u = edge[i].u, v = edge[i].v;
        db w = edge[i].cost;
        if (!merge(u, v)) continue;
        ans += w;
    }
    return (0 < (db)f - ans);
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n >> m >> f;
    for (int i = 1; i <= m; i++) cin >> edge[i].u >> edge[i].v >> edge[i].c >> edge[i].t;

    db l = 0, r = 1e10, esp = 1e-6;
    // db l = 0, r = 1e2, esp = 1e-6;
    while (r - l > esp) {
        db mid = (l + r) / 2;
        if (check(mid)) l = mid;
        else r = mid;
    }
    printf("%.4lf\n", l);

    return 0;
}
```

## 下午（树形DP）
### P2018 消息传递
#### 思路
- 可以枚举每个点作为开头，然后就可以进行树形 `DP` 了，注意建双向边。
#### Code
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef pair<int, int> pii;
const int MAXN = 1000 + 5;

int n;
int deg[MAXN];
vector<int> g[MAXN];
vector<pii> ans;
int dfs(int u, int fa) {
    vector<int> tmp;
    for (auto v : g[u]) {
        if (v == fa) continue;
        tmp.push_back(dfs(v, u));
    }
    sort(tmp.begin(), tmp.end(), greater<int>());

    int ans = 0;
    for (int i = 0; i < tmp.size(); i++) ans = max(ans, tmp[i] + i + 1);
    return ans;
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n;
    for (int u = 2; u <= n; u++) {
        int v;
        cin >> v;   
        g[v].push_back(u);
        g[u].push_back(v);
    }
    int minn = (int)1e9;
    for (int i = 1; i <= n; i++) { // 枚举出发点
        int u = dfs(i, 0) + 1;
        ans.push_back({u, i});
        minn = min(minn, u);
    }

    cout << minn << "\n";
    for (auto u : ans) {
        if (u.first == minn) cout << u.second << " ";
    }
    cout << "\n";
    
    return 0;
}
```

### P3554 [POI 2013] LUK-Triumphal arch
#### 思路
因为我们不知道这个 $k$ 是多少，而且需要求这个 $k$ 的最小值，所以我们就可以使用二分来求出这个 $k$ 最小是多少。

假设我们二分了一个 $k$，表示每次 $A$ 可以染 $k$ 个节点。设 $dp_u$ 表示节点 $u$ 这个点需要借多少个染色次数。一开始我们可以发现需要给儿子们染色，如果有多余的染色次数，就看有没有孩子需要借染色次数的。最后判断根节点是否需要借，如果还要借说明 $k$ 小了，否则更新答案而且将 $k$ 变小（查找最优解）。
#### Code
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = (int)3e5 + 5;

int n, k;
int dp[MAXN]; // 1.dp[i] <= 0：不用借，2.dp[i] > 0：需要借
vector<int> g[MAXN];

void dfs(int u, int fa) {
    int cnt = 0;
    dp[u] = 0;
    for (auto v : g[u]) {
        if (v == fa) continue;
        dfs(v, u);

        cnt++;
        if (dp[v] > 0) dp[u] += dp[v];
    }
    dp[u] += cnt - k;
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n;
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }

    // int l = 3, r = 3, ans = (int)3e5;
    int l = 0, r = (int)3e5, ans = (int)3e5;
    while (l <= r) {
        int mid = (l + r) >> 1;
        k = mid;

        dfs(1, 0);
        if (dp[1] > 0) l = mid + 1;
        else {
            ans = min(ans, mid);
            r = mid - 1;
        }
    }
    cout << ans << "\n";

    return 0;
}
```

### P11018 Monochrome Tree
#### 思路
有两个操作，操作一可以反转祖先，操作二可以反转子树。

有两个操作太麻烦，我们不妨先考虑操作二，并设出 $dp$ 数组：$dp_{u, (0/1)}$ 表示将 $u$ 为根的子树变为颜色 $0/1$ 所需要的最少操作。那么转移就是显然的了：

```cpp
dp[u][0] = max(sum(dp[v][1]) + 1, sum(dp[v][0]))
dp[u][1] = max(sum(dp[v][0]) + 1, sum(dp[v][1]))
```

如果加入操作一对当前有什么影响呢？我们发现我不知道当前节点 $u$ 的祖先被反转了几次，我们可以考虑扩维。设 $dp_{i, (0/1), (0/1)}$ 表示将 $u$ 为根的子树变为颜色 $0/1$ 且这个节点受到操作一 $(0)$ 偶数次或 $(1)$ 奇数次所使用的最小次数。（显然操作次数可以只分奇偶，因为操作偶数次相当于没操作）

而对于转移，假设当前根节点为 $u$，我们可以设 $f_{(0/1), (0/1)}$ 表示将 $u$ 的子树（包括 $u$ ）变为 $0/1$，且对 $u$ 点进行奇数次 $(1)$ 或偶数次 $(0)$ 操作一。

我们只需要处理出这个 $f$ 数组就可以算出 $dp$ 数组了。
#### Code
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MAXN = (int)2e5 + 5;
const int INF = (int)1e9;

int n, dp[MAXN][2][2];
bool col[MAXN]; // 颜色
vector<int> g[MAXN];

void dfs(int u, int fa) {
	dp[u][0][0] = dp[u][0][1] = dp[u][1][0] = dp[u][1][1] = INF; // 注意需要初始化数组
	if ((fa == 0 && g[u].empty()) || (fa > 0 && g[u].size() == 1)) { // 叶子节点
		dp[u][col[u]][0] = 0; // 不进行任何操作就可以达成
		dp[u][col[u]][1] = 2; // 操作1和操作2各进行一次
		dp[u][!col[u]][0] = 1; // 进行一次操作2
		dp[u][!col[u]][1] = 1; // 进行一次操作1
		return ;
	}
	
	int f[2][2] = {{0, INF}, {0, INF}};
	int ff, ft, tf, tt;
	for (auto v : g[u]) {
		if (v == fa) continue;
		dfs(v, u);
		
		ff = min(f[0][0] + dp[v][0][0], f[0][1] + dp[v][0][1]);
		ft = min(f[0][1] + dp[v][0][0], f[0][0] + dp[v][0][1]);
		tf = min(f[1][0] + dp[v][1][0], f[1][1] + dp[v][1][1]);
		tt = min(f[1][1] + dp[v][1][0], f[1][0] + dp[v][1][1]);
		f[0][0] = ff; f[0][1] = ft;
		f[1][0] = tf; f[1][1] = tt;
	}
	dp[u][col[u]][0] = min(f[col[u]][0], f[col[u]][1] + 1);
	dp[u][col[u]][1] = min(f[!col[u]][0] + 2, f[!col[u]][1] + 1);
	dp[u][!col[u]][0] = min(f[col[u]][0] + 1, f[col[u]][1] + 2);
	dp[u][!col[u]][1] = min(f[!col[u]][0] + 1, f[!col[u]][1]);
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	
	cin >> n;
	for (int i = 1; i <= n; i++) {
		int c; cin >> c;
		col[i] = c;
	}
	for (int i = 1; i < n; i++) {
		int u, v;
		cin >> u >> v;
		g[u].push_back(v);
		g[v].push_back(u);
	} 
	
	dfs(1, 0);
	cout << min({dp[1][0][0] + 1, dp[1][0][1] + 1, dp[1][1][0], dp[1][1][1]}) << "\n";
	return 0;
}
```

---
# Day 5
## 上午（模拟赛）
题目有点难。
## 下午
老师生病了，顺延至 $Day \ 7$ 上午。

---
# Day 6
## 上午（模拟赛讲解）
由于是北大的罗碚老师出的题，题目我觉得太难了，这里就不分享做法了。

## 下午（线段树基础）
### P3740 [HAOI2014] 贴海报
#### 思路
- 发现第 $u$ 张海报不会被 $[1, u -1]$ 的海报覆盖，所以我们考虑从后往前，如果这个区间有至少一个海报没有被覆盖，那么这个海报就一定不会被覆盖。
- 维护这个区间内的覆盖/没覆盖信息（我们使用线段树维护来降低我们的时间复杂度）。

这道题目可以不使用离散化，但是这里会说一个使用离散化需要注意的点，如果我们只是离散化 $l[i]$ 和 $r[i]$，那么当遇到这个数据会出错：
```
+-----------------墙-------------------+
		 +-------海报3-----+             
+----海报1------+    +----海报2-----+ 
```
对于这个数据，如果按照以上的离散化方法离散化，会发现错误，

#### Code
##### 不离散化版
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MAXN = (int)1e7 + 5, MAXM = (int)1e3 + 5;

int n, m;
bool color;

struct Q {
	int l, r;
} q[MAXM];
struct SegmentTree{
	struct Seg{
		bool u;
	} t[2 * MAXN];
	int ls[2 * MAXN], rs[2 * MAXN], scnt;

	void push_up(int u) {
		t[u].u |= (t[ls[u]].u && t[rs[u]].u);
	}
	int build(int l, int r) {
		int u = ++scnt;
		if (l == r) return u;
		
		int mid = (l + r) >> 1;
		ls[u] = build(l, mid);
		rs[u] = build(mid + 1, r);
		return u;
	}
	void update(int u, int l, int r, int ql, int qr) { // 区间修改
		if (t[u].u) return ;
		if (ql <= l && qr >= r) {
			t[u].u = true;
			color = true;
			return ;
		}
		int mid = (l + r) >> 1;
		if (ql <= mid) update(ls[u], l, mid, ql, qr);
		if (qr > mid) update(rs[u], mid + 1, r, ql, qr);
		push_up(u);
	}
	void printseg(int u, int l, int r) {
		if (l == r) {
			cout << u << " " << t[u].u << "\n";
			return ;
		}
		int mid = (l + r) >> 1;
		printseg(ls[u], l, mid);
		printseg(rs[u], mid + 1, r);
	}
} seg;

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		cin >> q[i].l >> q[i].r;
	}
	
	seg.build(1, n);
	int ans = 0;
	for (int i = m; i >= 1; i--) {
		color = false;
		seg.update(1, 1, n, q[i].l, q[i].r);
		if (color) ans++; 
	}
	cout << ans << "\n";
	
	return 0;
}
```

##### 离散化版
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MAXN = (int)1e7 + 5, MAXM = (int)1e3 + 5;

int n, m;
int d[MAXM * 4], dcnt; // 离散化数组
bool color;

struct Q {
	int l, r;
} q[MAXM];
struct SegmentTree{
	struct Seg{
		bool u;
	} t[2 * 4 * MAXM];
	int ls[2 * 4 * MAXM], rs[2 * 4 * MAXM], scnt;

	void push_up(int u) {
		t[u].u |= (t[ls[u]].u && t[rs[u]].u);
	}
	int build(int l, int r) {
		int u = ++scnt;
		if (l == r) return u;
		
		int mid = (l + r) >> 1;
		ls[u] = build(l, mid);
		rs[u] = build(mid + 1, r);
		return u;
	}
	void update(int u, int l, int r, int ql, int qr) { // 区间修改
		if (t[u].u) return ;
		if (ql <= l && qr >= r) {
			t[u].u = true;
			color = true;
			return ;
		}
		int mid = (l + r) >> 1;
		if (ql <= mid) update(ls[u], l, mid, ql, qr);
		if (qr > mid) update(rs[u], mid + 1, r, ql, qr);
		push_up(u);
	}
	void printseg(int u, int l, int r) {
		if (l == r) {
			cout << u << " " << t[u].u << "\n";
			return ;
		}
		int mid = (l + r) >> 1;
		printseg(ls[u], l, mid);
		printseg(rs[u], mid + 1, r);
	}
} seg;

int find_d(int u) {
	return lower_bound(d + 1, d + dcnt + 1, u) - d;
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		cin >> q[i].l >> q[i].r;
		d[++dcnt] = q[i].l;
		d[++dcnt] = q[i].r;
		d[++dcnt] = q[i].l - 1;
		d[++dcnt] = q[i].r + 1;
	}
	sort(d + 1, d + dcnt + 1);
	dcnt = unique(d + 1, d + dcnt + 1) - (d + 1);
	
	seg.build(1, dcnt);
	int ans = 0;
	for (int i = m; i >= 1; i--) {
		int nl = find_d(q[i].l), nr = find_d(q[i].r);
		color = false;
		seg.update(1, 1, dcnt, nl, nr);
		if (color) ans++; 
	}
	cout << ans << "\n";
	
	return 0;
}
```

---

# Day 7
## 上午（线段树进阶）


# 集训队总结
这次集训队巩固了很多知识点，以下是我对每一天讲的算法/数据结构的总结：

1. 单调性问题不一定是带 "单调" 的数据结构（如：单调队列，单调栈），一般是用于优化 $DP$， 或一些像求极值的问题。在考试的时候 $T2$ 使用了类似玉蟾宫的方法，也就是预处理一个 $pre$ 数组，这个比较神奇。
2. 区间一般是从小区间到大区间的转移，我们需要区分哪些转移是正确但不全面，有些转移可能不全面，但不代表这个转移不对。如果缺少状态就加状态（不要怕超时，因为有可能会使用像单调队列一样优化方法）。
3. 最小生成树要变成一个工具，不是所有题都只是将模板改一改就结束了，比如 [P3104 USACO14MAR Counting Friend G](https://www.luogu.com.cn/problem/P3104)，这题就是使用生成树的思维来解题的。
4. 最近公共祖先可以使用 $dfn$ 序 + $ST$ 表求出，这样时间复杂度和空间复杂度和代码长度都远优于倍增求 $LCA$ 和欧拉序 + $ST$ 表。
5. [模拟赛的 T3](https://www.luogu.com.cn/problem/P5189) 会用到 01分数规划，这个需要推式子，然后看二分那个变量可以保证有单调性。而且模拟赛 T3 需要发现可以将边的花费通过式子拆出来。

---
`update:2025/8/10` `author: Vickwan`